it's a FULL-STACK web framework

pip install Django (or django)

set a new project (environment): django-admin startproject my_site

manage.py and urls.py are really important initially

used to test from the beggining (like a flask run): python manage.py runserver <optional port number>

to create an app: python manage.py startapp my_app

now we will modify some files in order to make the app work properly

views.py store different views for the app (web pages)

on views.py:
from django.http import HttpResponse
def index(request):
    return HttpResponse('hello world!')  # accepts text or html

create urls.py inside main, they will contain paths to the different web pages

on main/urls.py:
from django.urls import path
from . import views
urlpatterns = [
    path("", views.index, name="index")
]

after that, we have to link the app to the project

on my_site/urls.py:
from django.urls import path, include
urlpatterns = [
    path('', include("main.urls"))
]

here we have specified a base path (it's empty, but it could be 'home/') that is linked to main.urls. anything after that will be handled by the main/urls.py

in order to set up a database, we need to append the name of the app in settings.INSTALLED_APPS, but with a specific syntax: "principal.apps.PrincipalConfig"

to make it work: python manage.py migrate

then, you will create classes within models.py. the attributes will be class attributes instead of instance attributes. it's important to add __str__ methods too

python manage.py makemigrations principal

makemigrations make new migrations, migrate apply them

then python manage.py migrate, again

making migrations is like adding something to the staging area in git

to open a django interactive shell: python manage.py shell

you can manipulate the models and its data from the shell

check 'manage shell'.png

now you can see dynamic pages being shown just by typing something in the url bar

to do this, you will need to set path("<int:id>", views.index, name="index") inside principal.urls.urlpatterns and 
def index(request, id):    
    ls = ToDoList.objects.get(id=id)
    return HttpResponse(f'<h1> {ls.name} </h1>')
inside views.py

we can also do:
def index(request, id):
    ls = ToDoList.objects.get(id=id)
    item = ls.item_set.get(id=1)
    return HttpResponse(f'<h1> {ls.name} </h1> <br> <h2> {item.text} </h2>')

for the admin dashboard you first have to create a log in account

to create an account: python manage.py createsuperuser, then choose a name, e-mail address and password

you need to add the database you've created to the dashboard via admin.py: 
from .models import ToDoList, Item
admin.site.register(ToDoList)
admin.site.register(Item)

templates are html files that will be dynamically changed using the django template language: {% %} and {{ }}. you call a template rendering from the view functions using data from the models

templates connect the back-end and the front-end

you need to create a templates/ directory inside my_app/ directory and then a my_app/ directory within it

template inheritance: {% extends 'my_app/layout.html' %}

return render() instead of return HttpResponse()

render(request, "my_app/layout.html", {})

in a for loop inside {% %}, use foo.item_set.all instead of foo.item_set.all()

to work with forms, you have to use the {{ form }} variable inside your <form> tag. you will create a form class and the instantiate it

check out the form.png image

create forms.py inside your app directory:
from django import forms
class CreateNewList(forms.Form):
    name = forms.CharField(label="Name", max_length=200)
    check = forms.BooleanField()

and them do an import at the views.py file:
from .forms import CreateNewList

finally, you will pass an intance of the class as the form variable: {"form": CreateNewList()}

you also have to write create.html and reference it in the return of the view

so basically, django forms can be automatically generated

form.as_p, .as_ul, as_table...

add {% csrf_token %} inside the form tag

get methods writes text in the url after ?

podemos fazer o seguinte:
if request.method == 'POST':
    form = CreateNewList(request.POST)

exemplo de request.POST: <QueryDict: {'csrfmiddlewaretoken': ['CBPNtdFryvc8tIJv0s8X2rWo70IQvDwxbVkWo1TfHm0i3tFTZCNNizRk8dGXMhpn'], 'name': ['foo'], 'check': ['on'], 'save': ['']}>

you can create new models with the form, check out the code at this commit
